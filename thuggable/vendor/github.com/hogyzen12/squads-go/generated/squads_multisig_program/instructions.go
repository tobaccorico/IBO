// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package squads_multisig_program

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

var ProgramID ag_solanago.PublicKey = ag_solanago.MustPublicKeyFromBase58("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")

func SetProgramID(pubkey ag_solanago.PublicKey) {
	ProgramID = pubkey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

const ProgramName = "SquadsMultisigProgram"

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var (
	// Initialize the program config.
	Instruction_ProgramConfigInit = ag_binary.TypeID([8]byte{184, 188, 198, 195, 205, 124, 117, 216})

	// Set the `authority` parameter of the program config.
	Instruction_ProgramConfigSetAuthority = ag_binary.TypeID([8]byte{238, 242, 36, 181, 32, 143, 216, 75})

	// Set the `multisig_creation_fee` parameter of the program config.
	Instruction_ProgramConfigSetMultisigCreationFee = ag_binary.TypeID([8]byte{101, 160, 249, 63, 154, 215, 153, 13})

	// Set the `treasury` parameter of the program config.
	Instruction_ProgramConfigSetTreasury = ag_binary.TypeID([8]byte{111, 46, 243, 117, 144, 188, 162, 107})

	// Create a multisig.
	Instruction_MultisigCreate = ag_binary.TypeID([8]byte{122, 77, 80, 159, 84, 88, 90, 197})

	// Create a multisig.
	Instruction_MultisigCreateV2 = ag_binary.TypeID([8]byte{50, 221, 199, 93, 40, 245, 139, 233})

	// Add a new member to the controlled multisig.
	Instruction_MultisigAddMember = ag_binary.TypeID([8]byte{1, 219, 215, 108, 184, 229, 214, 8})

	// Remove a member/key from the controlled multisig.
	Instruction_MultisigRemoveMember = ag_binary.TypeID([8]byte{217, 117, 177, 210, 182, 145, 218, 72})

	// Set the `time_lock` config parameter for the controlled multisig.
	Instruction_MultisigSetTimeLock = ag_binary.TypeID([8]byte{148, 154, 121, 77, 212, 254, 155, 72})

	// Set the `threshold` config parameter for the controlled multisig.
	Instruction_MultisigChangeThreshold = ag_binary.TypeID([8]byte{141, 42, 15, 126, 169, 92, 62, 181})

	// Set the multisig `config_authority`.
	Instruction_MultisigSetConfigAuthority = ag_binary.TypeID([8]byte{143, 93, 199, 143, 92, 169, 193, 232})

	// Set the multisig `rent_collector`.
	Instruction_MultisigSetRentCollector = ag_binary.TypeID([8]byte{48, 204, 65, 57, 210, 70, 156, 74})

	// Create a new spending limit for the controlled multisig.
	Instruction_MultisigAddSpendingLimit = ag_binary.TypeID([8]byte{11, 242, 159, 42, 86, 197, 89, 115})

	// Remove the spending limit from the controlled multisig.
	Instruction_MultisigRemoveSpendingLimit = ag_binary.TypeID([8]byte{228, 198, 136, 111, 123, 4, 178, 113})

	// Create a new config transaction.
	Instruction_ConfigTransactionCreate = ag_binary.TypeID([8]byte{155, 236, 87, 228, 137, 75, 81, 39})

	// Execute a config transaction.
	// The transaction must be `Approved`.
	Instruction_ConfigTransactionExecute = ag_binary.TypeID([8]byte{114, 146, 244, 189, 252, 140, 36, 40})

	// Create a new vault transaction.
	Instruction_VaultTransactionCreate = ag_binary.TypeID([8]byte{48, 250, 78, 168, 208, 226, 218, 211})

	// Create a transaction buffer account.
	Instruction_TransactionBufferCreate = ag_binary.TypeID([8]byte{245, 201, 113, 108, 37, 63, 29, 89})

	// Close a transaction buffer account.
	Instruction_TransactionBufferClose = ag_binary.TypeID([8]byte{17, 182, 208, 228, 136, 24, 178, 102})

	// Extend a transaction buffer account.
	Instruction_TransactionBufferExtend = ag_binary.TypeID([8]byte{230, 157, 67, 56, 5, 238, 245, 146})

	// Create a new vault transaction from a completed transaction buffer.
	// Finalized buffer hash must match `final_buffer_hash`
	Instruction_VaultTransactionCreateFromBuffer = ag_binary.TypeID([8]byte{222, 54, 149, 68, 87, 246, 48, 231})

	// Execute a vault transaction.
	// The transaction must be `Approved`.
	Instruction_VaultTransactionExecute = ag_binary.TypeID([8]byte{194, 8, 161, 87, 153, 164, 25, 171})

	// Create a new batch.
	Instruction_BatchCreate = ag_binary.TypeID([8]byte{194, 142, 141, 17, 55, 185, 20, 248})

	// Add a transaction to the batch.
	Instruction_BatchAddTransaction = ag_binary.TypeID([8]byte{89, 100, 224, 18, 69, 70, 54, 76})

	// Execute a transaction from the batch.
	Instruction_BatchExecuteTransaction = ag_binary.TypeID([8]byte{172, 44, 179, 152, 21, 127, 234, 180})

	// Create a new multisig proposal.
	Instruction_ProposalCreate = ag_binary.TypeID([8]byte{220, 60, 73, 224, 30, 108, 79, 159})

	// Update status of a multisig proposal from `Draft` to `Active`.
	Instruction_ProposalActivate = ag_binary.TypeID([8]byte{11, 34, 92, 248, 154, 27, 51, 106})

	// Approve a multisig proposal on behalf of the `member`.
	// The proposal must be `Active`.
	Instruction_ProposalApprove = ag_binary.TypeID([8]byte{144, 37, 164, 136, 188, 216, 42, 248})

	// Reject a multisig proposal on behalf of the `member`.
	// The proposal must be `Active`.
	Instruction_ProposalReject = ag_binary.TypeID([8]byte{243, 62, 134, 156, 230, 106, 246, 135})

	// Cancel a multisig proposal on behalf of the `member`.
	// The proposal must be `Approved`.
	Instruction_ProposalCancel = ag_binary.TypeID([8]byte{27, 42, 127, 237, 38, 163, 84, 203})

	// Cancel a multisig proposal on behalf of the `member`.
	// The proposal must be `Approved`.
	// This was introduced to incorporate proper state update, as old multisig members
	// may have lingering votes, and the proposal size may need to be reallocated to
	// accommodate the new amount of cancel votes.
	// The previous implemenation still works if the proposal size is in line with the
	// threshold size.
	Instruction_ProposalCancelV2 = ag_binary.TypeID([8]byte{205, 41, 194, 61, 220, 139, 16, 247})

	// Use a spending limit to transfer tokens from a multisig vault to a destination account.
	Instruction_SpendingLimitUse = ag_binary.TypeID([8]byte{16, 57, 130, 127, 193, 20, 155, 134})

	// Closes a `ConfigTransaction` and the corresponding `Proposal`.
	// `transaction` can be closed if either:
	// - the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
	// - the `proposal` is stale.
	Instruction_ConfigTransactionAccountsClose = ag_binary.TypeID([8]byte{80, 203, 84, 53, 151, 112, 187, 186})

	// Closes a `VaultTransaction` and the corresponding `Proposal`.
	// `transaction` can be closed if either:
	// - the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
	// - the `proposal` is stale and not `Approved`.
	Instruction_VaultTransactionAccountsClose = ag_binary.TypeID([8]byte{196, 71, 187, 176, 2, 35, 170, 165})

	// Closes a `VaultBatchTransaction` belonging to the `batch` and `proposal`.
	// `transaction` can be closed if either:
	// - it's marked as executed within the `batch`;
	// - the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
	// - the `proposal` is stale and not `Approved`.
	Instruction_VaultBatchTransactionAccountClose = ag_binary.TypeID([8]byte{134, 18, 19, 106, 129, 68, 97, 247})

	// Closes Batch and the corresponding Proposal accounts for proposals in terminal states:
	// `Executed`, `Rejected`, or `Cancelled` or stale proposals that aren't `Approved`.
	//
	// This instruction is only allowed to be executed when all `VaultBatchTransaction` accounts
	// in the `batch` are already closed: `batch.size == 0`.
	Instruction_BatchAccountsClose = ag_binary.TypeID([8]byte{218, 196, 7, 175, 130, 102, 11, 255})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_ProgramConfigInit:
		return "ProgramConfigInit"
	case Instruction_ProgramConfigSetAuthority:
		return "ProgramConfigSetAuthority"
	case Instruction_ProgramConfigSetMultisigCreationFee:
		return "ProgramConfigSetMultisigCreationFee"
	case Instruction_ProgramConfigSetTreasury:
		return "ProgramConfigSetTreasury"
	case Instruction_MultisigCreate:
		return "MultisigCreate"
	case Instruction_MultisigCreateV2:
		return "MultisigCreateV2"
	case Instruction_MultisigAddMember:
		return "MultisigAddMember"
	case Instruction_MultisigRemoveMember:
		return "MultisigRemoveMember"
	case Instruction_MultisigSetTimeLock:
		return "MultisigSetTimeLock"
	case Instruction_MultisigChangeThreshold:
		return "MultisigChangeThreshold"
	case Instruction_MultisigSetConfigAuthority:
		return "MultisigSetConfigAuthority"
	case Instruction_MultisigSetRentCollector:
		return "MultisigSetRentCollector"
	case Instruction_MultisigAddSpendingLimit:
		return "MultisigAddSpendingLimit"
	case Instruction_MultisigRemoveSpendingLimit:
		return "MultisigRemoveSpendingLimit"
	case Instruction_ConfigTransactionCreate:
		return "ConfigTransactionCreate"
	case Instruction_ConfigTransactionExecute:
		return "ConfigTransactionExecute"
	case Instruction_VaultTransactionCreate:
		return "VaultTransactionCreate"
	case Instruction_TransactionBufferCreate:
		return "TransactionBufferCreate"
	case Instruction_TransactionBufferClose:
		return "TransactionBufferClose"
	case Instruction_TransactionBufferExtend:
		return "TransactionBufferExtend"
	case Instruction_VaultTransactionCreateFromBuffer:
		return "VaultTransactionCreateFromBuffer"
	case Instruction_VaultTransactionExecute:
		return "VaultTransactionExecute"
	case Instruction_BatchCreate:
		return "BatchCreate"
	case Instruction_BatchAddTransaction:
		return "BatchAddTransaction"
	case Instruction_BatchExecuteTransaction:
		return "BatchExecuteTransaction"
	case Instruction_ProposalCreate:
		return "ProposalCreate"
	case Instruction_ProposalActivate:
		return "ProposalActivate"
	case Instruction_ProposalApprove:
		return "ProposalApprove"
	case Instruction_ProposalReject:
		return "ProposalReject"
	case Instruction_ProposalCancel:
		return "ProposalCancel"
	case Instruction_ProposalCancelV2:
		return "ProposalCancelV2"
	case Instruction_SpendingLimitUse:
		return "SpendingLimitUse"
	case Instruction_ConfigTransactionAccountsClose:
		return "ConfigTransactionAccountsClose"
	case Instruction_VaultTransactionAccountsClose:
		return "VaultTransactionAccountsClose"
	case Instruction_VaultBatchTransactionAccountClose:
		return "VaultBatchTransactionAccountClose"
	case Instruction_BatchAccountsClose:
		return "BatchAccountsClose"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			"program_config_init", (*ProgramConfigInit)(nil),
		},
		{
			"program_config_set_authority", (*ProgramConfigSetAuthority)(nil),
		},
		{
			"program_config_set_multisig_creation_fee", (*ProgramConfigSetMultisigCreationFee)(nil),
		},
		{
			"program_config_set_treasury", (*ProgramConfigSetTreasury)(nil),
		},
		{
			"multisig_create", (*MultisigCreate)(nil),
		},
		{
			"multisig_create_v2", (*MultisigCreateV2)(nil),
		},
		{
			"multisig_add_member", (*MultisigAddMember)(nil),
		},
		{
			"multisig_remove_member", (*MultisigRemoveMember)(nil),
		},
		{
			"multisig_set_time_lock", (*MultisigSetTimeLock)(nil),
		},
		{
			"multisig_change_threshold", (*MultisigChangeThreshold)(nil),
		},
		{
			"multisig_set_config_authority", (*MultisigSetConfigAuthority)(nil),
		},
		{
			"multisig_set_rent_collector", (*MultisigSetRentCollector)(nil),
		},
		{
			"multisig_add_spending_limit", (*MultisigAddSpendingLimit)(nil),
		},
		{
			"multisig_remove_spending_limit", (*MultisigRemoveSpendingLimit)(nil),
		},
		{
			"config_transaction_create", (*ConfigTransactionCreate)(nil),
		},
		{
			"config_transaction_execute", (*ConfigTransactionExecute)(nil),
		},
		{
			"vault_transaction_create", (*VaultTransactionCreate)(nil),
		},
		{
			"transaction_buffer_create", (*TransactionBufferCreate)(nil),
		},
		{
			"transaction_buffer_close", (*TransactionBufferClose)(nil),
		},
		{
			"transaction_buffer_extend", (*TransactionBufferExtend)(nil),
		},
		{
			"vault_transaction_create_from_buffer", (*VaultTransactionCreateFromBuffer)(nil),
		},
		{
			"vault_transaction_execute", (*VaultTransactionExecute)(nil),
		},
		{
			"batch_create", (*BatchCreate)(nil),
		},
		{
			"batch_add_transaction", (*BatchAddTransaction)(nil),
		},
		{
			"batch_execute_transaction", (*BatchExecuteTransaction)(nil),
		},
		{
			"proposal_create", (*ProposalCreate)(nil),
		},
		{
			"proposal_activate", (*ProposalActivate)(nil),
		},
		{
			"proposal_approve", (*ProposalApprove)(nil),
		},
		{
			"proposal_reject", (*ProposalReject)(nil),
		},
		{
			"proposal_cancel", (*ProposalCancel)(nil),
		},
		{
			"proposal_cancel_v2", (*ProposalCancelV2)(nil),
		},
		{
			"spending_limit_use", (*SpendingLimitUse)(nil),
		},
		{
			"config_transaction_accounts_close", (*ConfigTransactionAccountsClose)(nil),
		},
		{
			"vault_transaction_accounts_close", (*VaultTransactionAccountsClose)(nil),
		},
		{
			"vault_batch_transaction_account_close", (*VaultBatchTransactionAccountClose)(nil),
		},
		{
			"batch_accounts_close", (*BatchAccountsClose)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := DecodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func DecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
