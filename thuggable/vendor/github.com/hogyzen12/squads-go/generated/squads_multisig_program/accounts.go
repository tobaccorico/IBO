// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package squads_multisig_program

import (
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type Batch struct {
	// The multisig this belongs to.
	Multisig ag_solanago.PublicKey

	// Member of the Multisig who submitted the batch.
	Creator ag_solanago.PublicKey

	// Index of this batch within the multisig transactions.
	Index uint64

	// PDA bump.
	Bump uint8

	// Index of the vault this batch belongs to.
	VaultIndex uint8

	// Derivation bump of the vault PDA this batch belongs to.
	VaultBump uint8

	// Number of transactions in the batch.
	Size uint32

	// Index of the last executed transaction within the batch.
	// 0 means that no transactions have been executed yet.
	ExecutedTransactionIndex uint32
}

var BatchDiscriminator = [8]byte{156, 194, 70, 44, 22, 88, 137, 44}

func (obj Batch) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(BatchDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Multisig` param:
	err = encoder.Encode(obj.Multisig)
	if err != nil {
		return err
	}
	// Serialize `Creator` param:
	err = encoder.Encode(obj.Creator)
	if err != nil {
		return err
	}
	// Serialize `Index` param:
	err = encoder.Encode(obj.Index)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `VaultIndex` param:
	err = encoder.Encode(obj.VaultIndex)
	if err != nil {
		return err
	}
	// Serialize `VaultBump` param:
	err = encoder.Encode(obj.VaultBump)
	if err != nil {
		return err
	}
	// Serialize `Size` param:
	err = encoder.Encode(obj.Size)
	if err != nil {
		return err
	}
	// Serialize `ExecutedTransactionIndex` param:
	err = encoder.Encode(obj.ExecutedTransactionIndex)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Batch) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(BatchDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[156 194 70 44 22 88 137 44]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Multisig`:
	err = decoder.Decode(&obj.Multisig)
	if err != nil {
		return err
	}
	// Deserialize `Creator`:
	err = decoder.Decode(&obj.Creator)
	if err != nil {
		return err
	}
	// Deserialize `Index`:
	err = decoder.Decode(&obj.Index)
	if err != nil {
		return err
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `VaultIndex`:
	err = decoder.Decode(&obj.VaultIndex)
	if err != nil {
		return err
	}
	// Deserialize `VaultBump`:
	err = decoder.Decode(&obj.VaultBump)
	if err != nil {
		return err
	}
	// Deserialize `Size`:
	err = decoder.Decode(&obj.Size)
	if err != nil {
		return err
	}
	// Deserialize `ExecutedTransactionIndex`:
	err = decoder.Decode(&obj.ExecutedTransactionIndex)
	if err != nil {
		return err
	}
	return nil
}

type VaultBatchTransaction struct {
	// PDA bump.
	Bump uint8

	// Derivation bumps for additional signers.
	// Some transactions require multiple signers. Often these additional signers are "ephemeral" keypairs
	// that are generated on the client with a sole purpose of signing the transaction and be discarded immediately after.
	// When wrapping such transactions into multisig ones, we replace these "ephemeral" signing keypairs
	// with PDAs derived from the transaction's `transaction_index` and controlled by the Multisig Program;
	// during execution the program includes the seeds of these PDAs into the `invoke_signed` calls,
	// thus "signing" on behalf of these PDAs.
	EphemeralSignerBumps []byte

	// data required for executing the transaction.
	Message VaultTransactionMessage
}

var VaultBatchTransactionDiscriminator = [8]byte{196, 121, 46, 36, 12, 19, 252, 7}

func (obj VaultBatchTransaction) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(VaultBatchTransactionDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `EphemeralSignerBumps` param:
	err = encoder.Encode(obj.EphemeralSignerBumps)
	if err != nil {
		return err
	}
	// Serialize `Message` param:
	err = encoder.Encode(obj.Message)
	if err != nil {
		return err
	}
	return nil
}

func (obj *VaultBatchTransaction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(VaultBatchTransactionDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[196 121 46 36 12 19 252 7]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `EphemeralSignerBumps`:
	err = decoder.Decode(&obj.EphemeralSignerBumps)
	if err != nil {
		return err
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	return nil
}

type ConfigTransaction struct {
	// The multisig this belongs to.
	Multisig ag_solanago.PublicKey

	// Member of the Multisig who submitted the transaction.
	Creator ag_solanago.PublicKey

	// Index of this transaction within the multisig.
	Index uint64

	// bump for the transaction seeds.
	Bump uint8

	// Action to be performed on the multisig.
	Actions []ConfigAction
}

var ConfigTransactionDiscriminator = [8]byte{94, 8, 4, 35, 113, 139, 139, 112}

func (obj ConfigTransaction) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ConfigTransactionDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Multisig` param:
	err = encoder.Encode(obj.Multisig)
	if err != nil {
		return err
	}
	// Serialize `Creator` param:
	err = encoder.Encode(obj.Creator)
	if err != nil {
		return err
	}
	// Serialize `Index` param:
	err = encoder.Encode(obj.Index)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `Actions` param:
	err = encoder.Encode(obj.Actions)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ConfigTransaction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ConfigTransactionDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[94 8 4 35 113 139 139 112]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Multisig`:
	err = decoder.Decode(&obj.Multisig)
	if err != nil {
		return err
	}
	// Deserialize `Creator`:
	err = decoder.Decode(&obj.Creator)
	if err != nil {
		return err
	}
	// Deserialize `Index`:
	err = decoder.Decode(&obj.Index)
	if err != nil {
		return err
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `Actions`:
	err = decoder.Decode(&obj.Actions)
	if err != nil {
		return err
	}
	return nil
}

type Multisig struct {
	// Key that is used to seed the multisig PDA.
	CreateKey ag_solanago.PublicKey

	// The authority that can change the multisig config.
	// This is a very important parameter as this authority can change the members and threshold.
	//
	// The convention is to set this to `Pubkey::default()`.
	// In this case, the multisig becomes autonomous, so every config change goes through
	// the normal process of voting by the members.
	//
	// However, if this parameter is set to any other key, all the config changes for this multisig
	// will need to be signed by the `config_authority`. We call such a multisig a "controlled multisig".
	ConfigAuthority ag_solanago.PublicKey

	// Threshold for signatures.
	Threshold uint16

	// How many seconds must pass between transaction voting settlement and execution.
	TimeLock uint32

	// Last transaction index. 0 means no transactions have been created.
	TransactionIndex uint64

	// Last stale transaction index. All transactions up until this index are stale.
	// This index is updated when multisig config (members/threshold/time_lock) changes.
	StaleTransactionIndex uint64

	// The address where the rent for the accounts related to executed, rejected, or cancelled
	// transactions can be reclaimed. If set to `None`, the rent reclamation feature is turned off.
	RentCollector *ag_solanago.PublicKey `bin:"optional"`

	// Bump for the multisig PDA seed.
	Bump uint8

	// Members of the multisig.
	Members []Member
}

var MultisigDiscriminator = [8]byte{224, 116, 121, 186, 68, 161, 79, 236}

func (obj Multisig) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(MultisigDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `CreateKey` param:
	err = encoder.Encode(obj.CreateKey)
	if err != nil {
		return err
	}
	// Serialize `ConfigAuthority` param:
	err = encoder.Encode(obj.ConfigAuthority)
	if err != nil {
		return err
	}
	// Serialize `Threshold` param:
	err = encoder.Encode(obj.Threshold)
	if err != nil {
		return err
	}
	// Serialize `TimeLock` param:
	err = encoder.Encode(obj.TimeLock)
	if err != nil {
		return err
	}
	// Serialize `TransactionIndex` param:
	err = encoder.Encode(obj.TransactionIndex)
	if err != nil {
		return err
	}
	// Serialize `StaleTransactionIndex` param:
	err = encoder.Encode(obj.StaleTransactionIndex)
	if err != nil {
		return err
	}
	// Serialize `RentCollector` param (optional):
	{
		if obj.RentCollector == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.RentCollector)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `Members` param:
	err = encoder.Encode(obj.Members)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Multisig) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(MultisigDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[224 116 121 186 68 161 79 236]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `CreateKey`:
	err = decoder.Decode(&obj.CreateKey)
	if err != nil {
		return err
	}
	// Deserialize `ConfigAuthority`:
	err = decoder.Decode(&obj.ConfigAuthority)
	if err != nil {
		return err
	}
	// Deserialize `Threshold`:
	err = decoder.Decode(&obj.Threshold)
	if err != nil {
		return err
	}
	// Deserialize `TimeLock`:
	err = decoder.Decode(&obj.TimeLock)
	if err != nil {
		return err
	}
	// Deserialize `TransactionIndex`:
	err = decoder.Decode(&obj.TransactionIndex)
	if err != nil {
		return err
	}
	// Deserialize `StaleTransactionIndex`:
	err = decoder.Decode(&obj.StaleTransactionIndex)
	if err != nil {
		return err
	}
	// Deserialize `RentCollector` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.RentCollector)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `Members`:
	err = decoder.Decode(&obj.Members)
	if err != nil {
		return err
	}
	return nil
}

type ProgramConfig struct {
	// The authority which can update the config.
	Authority ag_solanago.PublicKey

	// The lamports amount charged for creating a new multisig account.
	// This fee is sent to the `treasury` account.
	MultisigCreationFee uint64

	// The treasury account to send charged fees to.
	Treasury ag_solanago.PublicKey

	// Reserved for future use.
	Reserved [64]uint8
}

var ProgramConfigDiscriminator = [8]byte{196, 210, 90, 231, 144, 149, 140, 63}

func (obj ProgramConfig) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ProgramConfigDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Authority` param:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return err
	}
	// Serialize `MultisigCreationFee` param:
	err = encoder.Encode(obj.MultisigCreationFee)
	if err != nil {
		return err
	}
	// Serialize `Treasury` param:
	err = encoder.Encode(obj.Treasury)
	if err != nil {
		return err
	}
	// Serialize `Reserved` param:
	err = encoder.Encode(obj.Reserved)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ProgramConfig) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ProgramConfigDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[196 210 90 231 144 149 140 63]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return err
	}
	// Deserialize `MultisigCreationFee`:
	err = decoder.Decode(&obj.MultisigCreationFee)
	if err != nil {
		return err
	}
	// Deserialize `Treasury`:
	err = decoder.Decode(&obj.Treasury)
	if err != nil {
		return err
	}
	// Deserialize `Reserved`:
	err = decoder.Decode(&obj.Reserved)
	if err != nil {
		return err
	}
	return nil
}

type Proposal struct {
	// The multisig this belongs to.
	Multisig ag_solanago.PublicKey

	// Index of the multisig transaction this proposal is associated with.
	TransactionIndex uint64

	// The status of the transaction.
	Status ProposalStatus

	// PDA bump.
	Bump uint8

	// Keys that have approved/signed.
	Approved []ag_solanago.PublicKey

	// Keys that have rejected.
	Rejected []ag_solanago.PublicKey

	// Keys that have cancelled (Approved only).
	Cancelled []ag_solanago.PublicKey
}

var ProposalDiscriminator = [8]byte{26, 94, 189, 187, 116, 136, 53, 33}

func (obj Proposal) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ProposalDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Multisig` param:
	err = encoder.Encode(obj.Multisig)
	if err != nil {
		return err
	}
	// Serialize `TransactionIndex` param:
	err = encoder.Encode(obj.TransactionIndex)
	if err != nil {
		return err
	}
	// Serialize `Status` param:
	{
		tmp := proposalStatusContainer{}
		switch realvalue := obj.Status.(type) {
		case *ProposalStatusDraft:
			tmp.Enum = 0
			tmp.Draft = *realvalue
		case *ProposalStatusActive:
			tmp.Enum = 1
			tmp.Active = *realvalue
		case *ProposalStatusRejected:
			tmp.Enum = 2
			tmp.Rejected = *realvalue
		case *ProposalStatusApproved:
			tmp.Enum = 3
			tmp.Approved = *realvalue
		case *ProposalStatusExecuting:
			tmp.Enum = 4
			tmp.Executing = *realvalue
		case *ProposalStatusExecuted:
			tmp.Enum = 5
			tmp.Executed = *realvalue
		case *ProposalStatusCancelled:
			tmp.Enum = 6
			tmp.Cancelled = *realvalue
		}
		err := encoder.Encode(tmp)
		if err != nil {
			return err
		}
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `Approved` param:
	err = encoder.Encode(obj.Approved)
	if err != nil {
		return err
	}
	// Serialize `Rejected` param:
	err = encoder.Encode(obj.Rejected)
	if err != nil {
		return err
	}
	// Serialize `Cancelled` param:
	err = encoder.Encode(obj.Cancelled)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Proposal) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ProposalDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[26 94 189 187 116 136 53 33]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Multisig`:
	err = decoder.Decode(&obj.Multisig)
	if err != nil {
		return err
	}
	// Deserialize `TransactionIndex`:
	err = decoder.Decode(&obj.TransactionIndex)
	if err != nil {
		return err
	}
	// Deserialize `Status`:
	{
		tmp := new(proposalStatusContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return err
		}
		switch tmp.Enum {
		case 0:
			obj.Status = &tmp.Draft
		case 1:
			obj.Status = &tmp.Active
		case 2:
			obj.Status = &tmp.Rejected
		case 3:
			obj.Status = &tmp.Approved
		case 4:
			obj.Status = (*ProposalStatusExecuting)(&tmp.Enum)
		case 5:
			obj.Status = &tmp.Executed
		case 6:
			obj.Status = &tmp.Cancelled
		default:
			return fmt.Errorf("unknown enum index: %v", tmp.Enum)
		}
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `Approved`:
	err = decoder.Decode(&obj.Approved)
	if err != nil {
		return err
	}
	// Deserialize `Rejected`:
	err = decoder.Decode(&obj.Rejected)
	if err != nil {
		return err
	}
	// Deserialize `Cancelled`:
	err = decoder.Decode(&obj.Cancelled)
	if err != nil {
		return err
	}
	return nil
}

type SpendingLimit struct {
	// The multisig this belongs to.
	Multisig ag_solanago.PublicKey

	// Key that is used to seed the SpendingLimit PDA.
	CreateKey ag_solanago.PublicKey

	// The index of the vault that the spending limit is for.
	VaultIndex uint8

	// The token mint the spending limit is for.
	// Pubkey::default() means SOL.
	// use NATIVE_MINT for Wrapped SOL.
	Mint ag_solanago.PublicKey

	// The amount of tokens that can be spent in a period.
	// This amount is in decimals of the mint,
	// so 1 SOL would be `1_000_000_000` and 1 USDC would be `1_000_000`.
	Amount uint64

	// The reset period of the spending limit.
	// When it passes, the remaining amount is reset, unless it's `Period::OneTime`.
	Period Period

	// The remaining amount of tokens that can be spent in the current period.
	// When reaches 0, the spending limit cannot be used anymore until the period reset.
	RemainingAmount uint64

	// Unix timestamp marking the last time the spending limit was reset (or created).
	LastReset int64

	// PDA bump.
	Bump uint8

	// Members of the multisig that can use the spending limit.
	// In case a member is removed from the multisig, the spending limit will remain existent
	// (until explicitly deleted), but the removed member will not be able to use it anymore.
	Members []ag_solanago.PublicKey

	// The destination addresses the spending limit is allowed to sent funds to.
	// If empty, funds can be sent to any address.
	Destinations []ag_solanago.PublicKey
}

var SpendingLimitDiscriminator = [8]byte{10, 201, 27, 160, 218, 195, 222, 152}

func (obj SpendingLimit) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(SpendingLimitDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Multisig` param:
	err = encoder.Encode(obj.Multisig)
	if err != nil {
		return err
	}
	// Serialize `CreateKey` param:
	err = encoder.Encode(obj.CreateKey)
	if err != nil {
		return err
	}
	// Serialize `VaultIndex` param:
	err = encoder.Encode(obj.VaultIndex)
	if err != nil {
		return err
	}
	// Serialize `Mint` param:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return err
	}
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `Period` param:
	err = encoder.Encode(obj.Period)
	if err != nil {
		return err
	}
	// Serialize `RemainingAmount` param:
	err = encoder.Encode(obj.RemainingAmount)
	if err != nil {
		return err
	}
	// Serialize `LastReset` param:
	err = encoder.Encode(obj.LastReset)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `Members` param:
	err = encoder.Encode(obj.Members)
	if err != nil {
		return err
	}
	// Serialize `Destinations` param:
	err = encoder.Encode(obj.Destinations)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SpendingLimit) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(SpendingLimitDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[10 201 27 160 218 195 222 152]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Multisig`:
	err = decoder.Decode(&obj.Multisig)
	if err != nil {
		return err
	}
	// Deserialize `CreateKey`:
	err = decoder.Decode(&obj.CreateKey)
	if err != nil {
		return err
	}
	// Deserialize `VaultIndex`:
	err = decoder.Decode(&obj.VaultIndex)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Period`:
	err = decoder.Decode(&obj.Period)
	if err != nil {
		return err
	}
	// Deserialize `RemainingAmount`:
	err = decoder.Decode(&obj.RemainingAmount)
	if err != nil {
		return err
	}
	// Deserialize `LastReset`:
	err = decoder.Decode(&obj.LastReset)
	if err != nil {
		return err
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `Members`:
	err = decoder.Decode(&obj.Members)
	if err != nil {
		return err
	}
	// Deserialize `Destinations`:
	err = decoder.Decode(&obj.Destinations)
	if err != nil {
		return err
	}
	return nil
}

type TransactionBuffer struct {
	// The multisig this belongs to.
	Multisig ag_solanago.PublicKey

	// Member of the Multisig who created the TransactionBuffer.
	Creator ag_solanago.PublicKey

	// Index to seed address derivation
	BufferIndex uint8

	// Vault index of the transaction this buffer belongs to.
	VaultIndex uint8

	// Hash of the final assembled transaction message.
	FinalBufferHash [32]uint8

	// The size of the final assembled transaction message.
	FinalBufferSize uint16

	// The buffer of the transaction message.
	Buffer []byte
}

var TransactionBufferDiscriminator = [8]byte{90, 36, 35, 219, 93, 225, 110, 96}

func (obj TransactionBuffer) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(TransactionBufferDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Multisig` param:
	err = encoder.Encode(obj.Multisig)
	if err != nil {
		return err
	}
	// Serialize `Creator` param:
	err = encoder.Encode(obj.Creator)
	if err != nil {
		return err
	}
	// Serialize `BufferIndex` param:
	err = encoder.Encode(obj.BufferIndex)
	if err != nil {
		return err
	}
	// Serialize `VaultIndex` param:
	err = encoder.Encode(obj.VaultIndex)
	if err != nil {
		return err
	}
	// Serialize `FinalBufferHash` param:
	err = encoder.Encode(obj.FinalBufferHash)
	if err != nil {
		return err
	}
	// Serialize `FinalBufferSize` param:
	err = encoder.Encode(obj.FinalBufferSize)
	if err != nil {
		return err
	}
	// Serialize `Buffer` param:
	err = encoder.Encode(obj.Buffer)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransactionBuffer) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(TransactionBufferDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[90 36 35 219 93 225 110 96]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Multisig`:
	err = decoder.Decode(&obj.Multisig)
	if err != nil {
		return err
	}
	// Deserialize `Creator`:
	err = decoder.Decode(&obj.Creator)
	if err != nil {
		return err
	}
	// Deserialize `BufferIndex`:
	err = decoder.Decode(&obj.BufferIndex)
	if err != nil {
		return err
	}
	// Deserialize `VaultIndex`:
	err = decoder.Decode(&obj.VaultIndex)
	if err != nil {
		return err
	}
	// Deserialize `FinalBufferHash`:
	err = decoder.Decode(&obj.FinalBufferHash)
	if err != nil {
		return err
	}
	// Deserialize `FinalBufferSize`:
	err = decoder.Decode(&obj.FinalBufferSize)
	if err != nil {
		return err
	}
	// Deserialize `Buffer`:
	err = decoder.Decode(&obj.Buffer)
	if err != nil {
		return err
	}
	return nil
}

type VaultTransaction struct {
	// The multisig this belongs to.
	Multisig ag_solanago.PublicKey

	// Member of the Multisig who submitted the transaction.
	Creator ag_solanago.PublicKey

	// Index of this transaction within the multisig.
	Index uint64

	// bump for the transaction seeds.
	Bump uint8

	// Index of the vault this transaction belongs to.
	VaultIndex uint8

	// Derivation bump of the vault PDA this transaction belongs to.
	VaultBump uint8

	// Derivation bumps for additional signers.
	// Some transactions require multiple signers. Often these additional signers are "ephemeral" keypairs
	// that are generated on the client with a sole purpose of signing the transaction and be discarded immediately after.
	// When wrapping such transactions into multisig ones, we replace these "ephemeral" signing keypairs
	// with PDAs derived from the MultisigTransaction's `transaction_index` and controlled by the Multisig Program;
	// during execution the program includes the seeds of these PDAs into the `invoke_signed` calls,
	// thus "signing" on behalf of these PDAs.
	EphemeralSignerBumps []byte

	// data required for executing the transaction.
	Message VaultTransactionMessage
}

var VaultTransactionDiscriminator = [8]byte{168, 250, 162, 100, 81, 14, 162, 207}

func (obj VaultTransaction) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(VaultTransactionDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Multisig` param:
	err = encoder.Encode(obj.Multisig)
	if err != nil {
		return err
	}
	// Serialize `Creator` param:
	err = encoder.Encode(obj.Creator)
	if err != nil {
		return err
	}
	// Serialize `Index` param:
	err = encoder.Encode(obj.Index)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `VaultIndex` param:
	err = encoder.Encode(obj.VaultIndex)
	if err != nil {
		return err
	}
	// Serialize `VaultBump` param:
	err = encoder.Encode(obj.VaultBump)
	if err != nil {
		return err
	}
	// Serialize `EphemeralSignerBumps` param:
	err = encoder.Encode(obj.EphemeralSignerBumps)
	if err != nil {
		return err
	}
	// Serialize `Message` param:
	err = encoder.Encode(obj.Message)
	if err != nil {
		return err
	}
	return nil
}

func (obj *VaultTransaction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(VaultTransactionDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[168 250 162 100 81 14 162 207]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Multisig`:
	err = decoder.Decode(&obj.Multisig)
	if err != nil {
		return err
	}
	// Deserialize `Creator`:
	err = decoder.Decode(&obj.Creator)
	if err != nil {
		return err
	}
	// Deserialize `Index`:
	err = decoder.Decode(&obj.Index)
	if err != nil {
		return err
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `VaultIndex`:
	err = decoder.Decode(&obj.VaultIndex)
	if err != nil {
		return err
	}
	// Deserialize `VaultBump`:
	err = decoder.Decode(&obj.VaultBump)
	if err != nil {
		return err
	}
	// Deserialize `EphemeralSignerBumps`:
	err = decoder.Decode(&obj.EphemeralSignerBumps)
	if err != nil {
		return err
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	return nil
}
